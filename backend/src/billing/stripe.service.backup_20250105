import { Injectable, Logger, BadRequestException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import Stripe from 'stripe';
import { PrismaService } from '../common/prisma/prisma.service';
import { EmailService } from '../email/email.service';

@Injectable()
export class StripeService {
  private readonly logger = new Logger(StripeService.name);
  private stripe: Stripe;

  constructor(
    private configService: ConfigService,
    private prisma: PrismaService,
    private emailService: EmailService,
  ) {
    this.stripe = new Stripe(this.configService.get('STRIPE_SECRET_KEY'), {
      apiVersion: '2023-10-16',
    });
  }

  /**
   * Tworzy checkout session dla nowej subskrypcji z 7-dniowym okresem pr√≥bnym
   */
  async createCheckoutSession({
    tenantId,
    planId,
    email,
    successUrl,
    cancelUrl,
  }: {
    tenantId: string;
    planId: string;
    email: string;
    successUrl: string;
    cancelUrl: string;
  }) {
    try {
      const plan = await this.prisma.subscription_plans.findUnique({
        where: { id: planId },
      });

      if (!plan || !plan.isActive) {
        throw new BadRequestException('Plan nie istnieje lub jest nieaktywny');
      }

      const tenant = await this.prisma.tenants.findUnique({
        where: { id: tenantId },
      });

      if (!tenant) {
        throw new BadRequestException('Firma nie istnieje');
      }

      // Sprawd≈∫ czy tenant ju≈º ma subskrypcjƒô
      const existingSubscription = await this.prisma.subscriptions.findUnique({
        where: { tenantId },
      });

      // Pozw√≥l na checkout je≈õli:
      // 1. Nie ma subskrypcji ALBO
      // 2. Ma lokalny trial (TRIALING bez stripeSubscriptionId) - mo≈ºe dodaƒá kartƒô ALBO
      // 3. Subskrypcja jest CANCELLED - u≈ºytkownik mo≈ºe za≈Ço≈ºyƒá nowƒÖ
      // Dla PAST_DUE - u≈ºytkownik powinien u≈ºyƒá billing portal do aktualizacji karty
      if (existingSubscription && existingSubscription.stripeSubscriptionId) {
        // PAST_DUE - subskrypcja nadal istnieje w Stripe, u≈ºytkownik musi zaktualizowaƒá kartƒô przez portal
        if (existingSubscription.status === 'PAST_DUE') {
          throw new BadRequestException(
            'Twoja subskrypcja wymaga aktualizacji metody p≈Çatno≈õci. U≈ºyj przycisku "Zaktualizuj metodƒô p≈Çatno≈õci" aby przej≈õƒá do portalu p≈Çatno≈õci.'
          );
        }
        
        // CANCELLED lub INCOMPLETE - mo≈ºna utworzyƒá nowƒÖ subskrypcjƒô
        const allowedStatuses = ['CANCELLED', 'INCOMPLETE'];
        if (!allowedStatuses.includes(existingSubscription.status)) {
          throw new BadRequestException('Firma ju≈º posiada aktywnƒÖ subskrypcjƒô');
        }
        
        this.logger.log(`Subskrypcja ${existingSubscription.status} - pozwalam na nowy checkout`);
      }

      // Utw√≥rz lub pobierz Stripe Customer
      let customer: Stripe.Customer;
      const existingCustomers = await this.stripe.customers.list({
        email,
        limit: 1,
      });

      if (existingCustomers.data.length > 0) {
        customer = existingCustomers.data[0];
        // Zaktualizuj istniejƒÖcego klienta - ustaw nazwƒô firmy je≈õli brakuje
        // Jest to wymagane dla tax_id_collection w Stripe Checkout
        if (!customer.name || customer.name !== tenant.name) {
          customer = await this.stripe.customers.update(customer.id, {
            name: tenant.name,
            metadata: {
              tenantId,
              tenantName: tenant.name,
            },
          });
          this.logger.log(`Zaktualizowano nazwƒô klienta Stripe ${customer.id} na "${tenant.name}"`);
        }
      } else {
        customer = await this.stripe.customers.create({
          email,
          name: tenant.name, // Dodaj nazwƒô przy tworzeniu
          metadata: {
            tenantId,
            tenantName: tenant.name,
          },
        });
      }

      // Utw√≥rz checkout session z okresem pr√≥bnym
      // U≈ºywamy payment_method_collection: 'always' aby wymagaƒá karty podczas trial
      const session = await this.stripe.checkout.sessions.create({
        customer: customer.id,
        mode: 'subscription',
        payment_method_types: ['card', 'link'],
        line_items: [
          {
            price: plan.stripePriceId,
            quantity: 1,
          },
        ],
        subscription_data: {
          trial_period_days: plan.trialDays,
          trial_settings: {
            end_behavior: {
              missing_payment_method: 'cancel', // Anuluj je≈õli brak karty po trial
            },
          },
          metadata: {
            tenantId,
            planId,
          },
        },
        payment_method_collection: 'always', // ZAWSZE wymagaj karty
        // Umo≈ºliw aktualizacjƒô danych firmy/nazwy wymaganych przy NIP
        customer_update: {
          name: 'auto',
          address: 'auto',
        },
        // Zbieranie NIP (Tax ID) - opcjonalne dla klienta, ale dostƒôpne od razu
        tax_id_collection: { enabled: true },
        // Zbieranie adresu rozliczeniowego
        billing_address_collection: 'required',
        // Automatyczne naliczanie podatku (opcjonalne)
        // automatic_tax: { enabled: true },
        success_url: successUrl,
        cancel_url: cancelUrl,
        metadata: {
          tenantId,
          planId,
        },
      });

      this.logger.log(`Utworzono checkout session dla tenant ${tenantId}: ${session.id}`);

      return {
        sessionId: session.id,
        url: session.url,
      };
    } catch (error) {
      this.logger.error('B≈ÇƒÖd podczas tworzenia checkout session', error);
      throw error;
    }
  }

  /**
   * Tworzy portal zarzƒÖdzania subskrypcjƒÖ
   */
  async createBillingPortalSession(tenantId: string, returnUrl: string) {
    try {
      const subscription = await this.prisma.subscriptions.findUnique({
        where: { tenantId },
      });

      if (!subscription) {
        throw new BadRequestException('Brak aktywnej subskrypcji');
      }

      // Sprawd≈∫ czy to prawdziwy Stripe Customer ID
      if (!subscription.stripeCustomerId || !subscription.stripeCustomerId.startsWith('cus_')) {
        // Je≈õli jest w trakcie trialu lokalnego, nie pozw√≥l na portal
        if (subscription.status === 'TRIALING' && !subscription.stripeSubscriptionId) {
          throw new BadRequestException('Najpierw dodaj kartƒô p≈ÇatniczƒÖ aby zarzƒÖdzaƒá subskrypcjƒÖ.');
        }
        // Je≈õli checkout by≈Ç niedawno, webhook mo≈ºe jeszcze nie dotrzeƒá
        const checkoutTime = subscription.updatedAt;
        const now = new Date();
        const timeDiff = now.getTime() - checkoutTime.getTime();
        if (timeDiff < 60000) { // Mniej ni≈º 1 minuta
          throw new BadRequestException('Przetwarzamy TwojƒÖ p≈Çatno≈õƒá. Spr√≥buj ponownie za chwilƒô (30-60 sekund).');
        }
        throw new BadRequestException('Subskrypcja nie jest po≈ÇƒÖczona ze Stripe. Skontaktuj siƒô z supportem.');
      }

      const session = await this.stripe.billingPortal.sessions.create({
        customer: subscription.stripeCustomerId,
        return_url: returnUrl,
      });

      return { url: session.url };
    } catch (error) {
      this.logger.error('B≈ÇƒÖd podczas tworzenia billing portal session', error);
      throw error;
    }
  }

  /**
   * Anuluje subskrypcjƒô na koniec okresu rozliczeniowego
   */
  async cancelSubscription(tenantId: string) {
    try {
      const subscription = await this.prisma.subscriptions.findUnique({
        where: { tenantId },
      });

      if (!subscription || !subscription.stripeSubscriptionId) {
        throw new BadRequestException('Brak aktywnej subskrypcji');
      }

      await this.stripe.subscriptions.update(subscription.stripeSubscriptionId, {
        cancel_at_period_end: true,
      });

      await this.prisma.subscriptions.update({
        where: { tenantId },
        data: {
          cancelAtPeriodEnd: true,
          canceledAt: new Date(),
        },
      });

      this.logger.log(`Anulowano subskrypcjƒô dla tenant ${tenantId}`);

      return { success: true };
    } catch (error) {
      this.logger.error('B≈ÇƒÖd podczas anulowania subskrypcji', error);
      throw error;
    }
  }

  /**
   * Wznawia anulowanƒÖ subskrypcjƒô
   */
  async resumeSubscription(tenantId: string) {
    try {
      const subscription = await this.prisma.subscriptions.findUnique({
        where: { tenantId },
      });

      if (!subscription || !subscription.stripeSubscriptionId) {
        throw new BadRequestException('Brak aktywnej subskrypcji');
      }

      await this.stripe.subscriptions.update(subscription.stripeSubscriptionId, {
        cancel_at_period_end: false,
      });

      await this.prisma.subscriptions.update({
        where: { tenantId },
        data: {
          cancelAtPeriodEnd: false,
          resumedAt: new Date(),
        },
      });

      this.logger.log(`Wznowiono subskrypcjƒô dla tenant ${tenantId}`);

      return { success: true };
    } catch (error) {
      this.logger.error('B≈ÇƒÖd podczas wznawiania subskrypcji', error);
      throw error;
    }
  }

  /**
   * Pobiera szczeg√≥≈Çy subskrypcji ze Stripe
   */
  async getSubscriptionDetails(tenantId: string) {
    try {
      const subscription = await this.prisma.subscriptions.findUnique({
        where: { tenantId },
        include: {
          subscription_plans: true,
        },
      });

      if (!subscription) {
        return null;
      }

      let stripeSubscription: Stripe.Subscription | null = null;
      if (subscription.stripeSubscriptionId) {
        stripeSubscription = await this.stripe.subscriptions.retrieve(
          subscription.stripeSubscriptionId,
        );
      }

      return {
        ...subscription,
        stripeDetails: stripeSubscription,
      };
    } catch (error) {
      this.logger.error('B≈ÇƒÖd podczas pobierania szczeg√≥≈Ç√≥w subskrypcji', error);
      throw error;
    }
  }

  /**
   * Obs≈Çuga webhook od Stripe
   */
  async handleWebhook(signature: string, payload: Buffer) {
    const webhookSecret = this.configService.get('STRIPE_WEBHOOK_SECRET');

    try {
      const event = this.stripe.webhooks.constructEvent(
        payload,
        signature,
        webhookSecret,
      );

      this.logger.log(`Otrzymano webhook Stripe: ${event.type}`);

      switch (event.type) {
        case 'checkout.session.completed':
          await this.handleCheckoutSessionCompleted(event.data.object as Stripe.Checkout.Session);
          break;

        case 'customer.subscription.created':
          await this.handleSubscriptionCreated(event.data.object as Stripe.Subscription);
          break;

        case 'customer.subscription.updated':
          await this.handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
          break;

        case 'customer.subscription.deleted':
          await this.handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
          break;

        case 'customer.subscription.trial_will_end':
          await this.handleTrialWillEnd(event.data.object as Stripe.Subscription);
          break;

        case 'invoice.paid':
          await this.handleInvoicePaid(event.data.object as Stripe.Invoice);
          break;

        case 'invoice.payment_failed':
          await this.handleInvoicePaymentFailed(event.data.object as Stripe.Invoice);
          break;

        case 'payment_method.attached':
          await this.handlePaymentMethodAttached(event.data.object as Stripe.PaymentMethod);
          break;

        default:
          this.logger.log(`Nieobs≈Çugiwany typ eventu: ${event.type}`);
      }

      return { received: true };
    } catch (error) {
      this.logger.error('B≈ÇƒÖd podczas obs≈Çugi webhooka Stripe', error);
      throw error;
    }
  }

  private async handleCheckoutSessionCompleted(session: Stripe.Checkout.Session) {
    const tenantId = session.metadata?.tenantId;
    const planId = session.metadata?.planId;

    if (!tenantId || !planId) {
      this.logger.error('Brak tenantId lub planId w metadata checkout session');
      return;
    }

    this.logger.log(`Checkout session zako≈Ñczony dla tenant ${tenantId}`);

    // Pobierz subskrypcjƒô ze Stripe je≈õli zosta≈Ça utworzona
    if (session.subscription) {
      try {
        const stripeSubscription = await this.stripe.subscriptions.retrieve(
          session.subscription as string
        );

        const trialEnd = stripeSubscription.trial_end
          ? new Date(stripeSubscription.trial_end * 1000)
          : null;

        const trialStart = stripeSubscription.trial_start
          ? new Date(stripeSubscription.trial_start * 1000)
          : null;

        // Utw√≥rz lub zaktualizuj subskrypcjƒô w bazie
        await this.prisma.subscriptions.upsert({
          where: { tenantId },
          create: {
            id: `sub_${Date.now()}`,
            status: stripeSubscription.status === 'trialing' ? 'TRIALING' : 'ACTIVE',
            stripeCustomerId: session.customer as string,
            stripeSubscriptionId: stripeSubscription.id,
            stripePaymentMethodId: stripeSubscription.default_payment_method as string,
            currentPeriodStart: new Date(stripeSubscription.current_period_start * 1000),
            currentPeriodEnd: new Date(stripeSubscription.current_period_end * 1000),
            trialStart,
            trialEnd,
            updatedAt: new Date(),
            tenants: {
              connect: { id: tenantId },
            },
            subscription_plans: {
              connect: { id: planId },
            },
          },
          update: {
            status: stripeSubscription.status === 'trialing' ? 'TRIALING' : 'ACTIVE',
            stripeCustomerId: session.customer as string,
            stripeSubscriptionId: stripeSubscription.id,
            stripePaymentMethodId: stripeSubscription.default_payment_method as string,
            currentPeriodStart: new Date(stripeSubscription.current_period_start * 1000),
            currentPeriodEnd: new Date(stripeSubscription.current_period_end * 1000),
            trialStart,
            trialEnd,
            updatedAt: new Date(),
          },
        });

        this.logger.log(`‚úÖ Utworzono/zaktualizowano subskrypcjƒô dla tenant ${tenantId} z checkout session`);

        // Wy≈õlij email o rozpoczƒôciu trialu
        if (stripeSubscription.status === 'trialing' && trialEnd) {
          const tenant = await this.prisma.tenants.findUnique({
            where: { id: tenantId },
          });

          if (tenant) {
            this.emailService.sendTrialStartedEmail(tenant.email, {
              name: tenant.name,
              trialDays: 7,
              trialEndDate: trialEnd.toLocaleDateString('pl-PL'),
            }).catch(err => {
              this.logger.error(`Failed to send trial started email:`, err);
            });
          }
        }
      } catch (error) {
        this.logger.error(`B≈ÇƒÖd podczas tworzenia subskrypcji z checkout session: ${error.message}`);
      }
    }
  }

  private async handleSubscriptionCreated(subscription: Stripe.Subscription) {
    const tenantId = subscription.metadata?.tenantId;
    const planId = subscription.metadata?.planId;

    if (!tenantId || !planId) {
      this.logger.error('Brak tenantId lub planId w metadata subskrypcji');
      return;
    }

    const trialEnd = subscription.trial_end
      ? new Date(subscription.trial_end * 1000)
      : null;

    const trialStart = subscription.trial_start
      ? new Date(subscription.trial_start * 1000)
      : null;

    // Utw√≥rz lub zaktualizuj subskrypcjƒô w bazie
    await this.prisma.subscriptions.upsert({
      where: { tenantId },
      create: {
        id: `sub_${Date.now()}`,
        status: subscription.status === 'trialing' ? 'TRIALING' : 'ACTIVE',
        stripeCustomerId: subscription.customer as string,
        stripeSubscriptionId: subscription.id,
        stripePaymentMethodId: subscription.default_payment_method as string,
        currentPeriodStart: new Date(subscription.current_period_start * 1000),
        currentPeriodEnd: new Date(subscription.current_period_end * 1000),
        trialStart,
        trialEnd,
        updatedAt: new Date(),
        tenants: {
          connect: { id: tenantId },
        },
        subscription_plans: {
          connect: { id: planId },
        },
      },
      update: {
        status: subscription.status === 'trialing' ? 'TRIALING' : 'ACTIVE',
        stripeSubscriptionId: subscription.id,
        stripePaymentMethodId: subscription.default_payment_method as string,
        currentPeriodStart: new Date(subscription.current_period_start * 1000),
        currentPeriodEnd: new Date(subscription.current_period_end * 1000),
        trialStart,
        trialEnd,
      },
    });

    this.logger.log(`Utworzono subskrypcjƒô dla tenant ${tenantId}`);

    // üìß Wy≈õlij email o rozpoczƒôciu trialu
    if (subscription.status === 'trialing' && trialEnd) {
      const tenant = await this.prisma.tenants.findUnique({
        where: { id: tenantId },
        include: { users: true },
      });

      if (tenant) {
        this.emailService.sendTrialStartedEmail(tenant.email, {
          name: tenant.name,
          trialDays: 7,
          trialEndDate: trialEnd.toLocaleDateString('pl-PL'),
        }).catch(err => {
          this.logger.error(`Failed to send trial started email:`, err);
        });
      }
    }
  }

  private async handleSubscriptionUpdated(subscription: Stripe.Subscription) {
    // Najpierw szukaj po stripeSubscriptionId
    let existingSubscription = await this.prisma.subscriptions.findFirst({
      where: { stripeSubscriptionId: subscription.id },
    });

    // Je≈õli nie znaleziono, szukaj po stripeCustomerId (mo≈ºe byƒá nowa subskrypcja dla tego samego klienta)
    if (!existingSubscription) {
      existingSubscription = await this.prisma.subscriptions.findFirst({
        where: { stripeCustomerId: subscription.customer as string },
      });
      
      if (existingSubscription) {
        this.logger.log(`Znaleziono subskrypcjƒô po customerId, aktualizujƒô stripeSubscriptionId`);
      }
    }

    // Je≈õli nadal nie znaleziono, szukaj po tenantId z metadata
    if (!existingSubscription && subscription.metadata?.tenantId) {
      existingSubscription = await this.prisma.subscriptions.findFirst({
        where: { tenantId: subscription.metadata.tenantId },
      });
      
      if (existingSubscription) {
        this.logger.log(`Znaleziono subskrypcjƒô po tenantId z metadata`);
      }
    }

    if (!existingSubscription) {
      this.logger.error(`Nie znaleziono subskrypcji dla Stripe ID: ${subscription.id}, customerId: ${subscription.customer}, tenantId: ${subscription.metadata?.tenantId}`);
      return;
    }

    let status: 'ACTIVE' | 'PAST_DUE' | 'CANCELLED' | 'TRIALING' | 'INCOMPLETE' = 'ACTIVE';

    switch (subscription.status) {
      case 'active':
        status = 'ACTIVE';
        break;
      case 'trialing':
        status = 'TRIALING';
        break;
      case 'past_due':
        status = 'PAST_DUE';
        break;
      case 'canceled':
        status = 'CANCELLED';
        break;
      case 'incomplete':
        status = 'INCOMPLETE';
        break;
    }

    await this.prisma.subscriptions.update({
      where: { id: existingSubscription.id },
      data: {
        status,
        stripeSubscriptionId: subscription.id, // Zawsze aktualizuj ID subskrypcji
        stripePaymentMethodId: subscription.default_payment_method as string,
        currentPeriodStart: new Date(subscription.current_period_start * 1000),
        currentPeriodEnd: new Date(subscription.current_period_end * 1000),
        cancelAtPeriodEnd: subscription.cancel_at_period_end,
        updatedAt: new Date(),
      },
    });

    this.logger.log(`Zaktualizowano subskrypcjƒô ${subscription.id} do statusu ${status}, okres: ${new Date(subscription.current_period_start * 1000).toISOString()} - ${new Date(subscription.current_period_end * 1000).toISOString()}`);

    // üìß Wy≈õlij email o aktywnej subskrypcji (gdy trial siƒô sko≈Ñczy≈Ç i subskrypcja jest aktywna)
    if (status === 'ACTIVE' && existingSubscription.status === 'TRIALING') {
      const tenant = await this.prisma.tenants.findUnique({
        where: { id: existingSubscription.tenantId },
      });

      if (tenant) {
        const nextBillingDate = new Date(subscription.current_period_end * 1000).toLocaleDateString('pl-PL');
        
        this.emailService.sendSubscriptionActiveEmail(tenant.email, {
          name: tenant.name,
          planName: 'Professional',
          nextBillingDate,
        }).catch(err => {
          this.logger.error(`Failed to send subscription active email:`, err);
        });
      }
    }
  }

  private async handleSubscriptionDeleted(subscription: Stripe.Subscription) {
    const existingSubscription = await this.prisma.subscriptions.findFirst({
      where: { stripeSubscriptionId: subscription.id },
    });

    if (!existingSubscription) {
      return;
    }

    await this.prisma.subscriptions.update({
      where: { id: existingSubscription.id },
      data: {
        status: 'CANCELLED',
        canceledAt: new Date(),
      },
    });

    // Zawie≈õ konto tenant
    await this.prisma.tenants.update({
      where: { id: existingSubscription.tenantId },
      data: {
        isSuspended: true,
        suspendedReason: 'Subskrypcja zosta≈Ça anulowana',
      },
    });

    this.logger.log(`Usuniƒôto subskrypcjƒô ${subscription.id}`);
  }

  private async handleTrialWillEnd(subscription: Stripe.Subscription) {
    const existingSubscription = await this.prisma.subscriptions.findFirst({
      where: { stripeSubscriptionId: subscription.id },
      include: { tenants: true },
    });

    if (!existingSubscription) {
      return;
    }

    this.logger.log(
      `Okres pr√≥bny ko≈Ñczy siƒô za 3 dni dla tenant ${existingSubscription.tenantId}`,
    );

    // üìß Wy≈õlij email o ko≈ÑczƒÖcym siƒô trialu
    if (existingSubscription.tenants) {
      const trialEndDate = subscription.trial_end 
        ? new Date(subscription.trial_end * 1000).toLocaleDateString('pl-PL')
        : 'wkr√≥tce';

      this.emailService.sendTrialEndingEmail(existingSubscription.tenants.email, {
        name: existingSubscription.tenants.name,
        daysLeft: 3,
        trialEndDate,
      }).catch(err => {
        this.logger.error(`Failed to send trial ending email:`, err);
      });
    }
  }

  private async handleInvoicePaid(invoice: Stripe.Invoice) {
    this.logger.log(`Faktura op≈Çacona: ${invoice.id}, subscription: ${invoice.subscription}, customer: ${invoice.customer}`);
    
    if (!invoice.subscription) {
      return;
    }

    // Szukaj subskrypcji po r√≥≈ºnych kryteriach
    let existingSubscription = await this.prisma.subscriptions.findFirst({
      where: { stripeSubscriptionId: invoice.subscription as string },
    });

    if (!existingSubscription) {
      existingSubscription = await this.prisma.subscriptions.findFirst({
        where: { stripeCustomerId: invoice.customer as string },
      });
    }

    if (!existingSubscription) {
      this.logger.error(`Nie znaleziono subskrypcji dla faktury ${invoice.id}`);
      return;
    }

    // Pobierz aktualny stan subskrypcji ze Stripe
    const stripeSubscription = await this.stripe.subscriptions.retrieve(invoice.subscription as string);

    // Zaktualizuj subskrypcjƒô w bazie - ustaw ACTIVE po op≈Çaceniu
    await this.prisma.subscriptions.update({
      where: { id: existingSubscription.id },
      data: {
        status: stripeSubscription.status === 'active' ? 'ACTIVE' : existingSubscription.status,
        stripeSubscriptionId: invoice.subscription as string,
        lastPaymentStatus: 'paid',
        lastPaymentError: null,
        currentPeriodStart: new Date(stripeSubscription.current_period_start * 1000),
        currentPeriodEnd: new Date(stripeSubscription.current_period_end * 1000),
        updatedAt: new Date(),
      },
    });

    this.logger.log(`Zaktualizowano subskrypcjƒô po op≈Çaceniu faktury: status=${stripeSubscription.status}, okres do ${new Date(stripeSubscription.current_period_end * 1000).toISOString()}`);

    // Odblokuj konto je≈õli by≈Ço zablokowane z powodu p≈Çatno≈õci
    const tenant = await this.prisma.tenants.findUnique({
      where: { id: existingSubscription.tenantId },
    });

    if (tenant?.isSuspended && tenant.suspendedReason?.includes('P≈Çatno≈õƒá')) {
      await this.prisma.tenants.update({
        where: { id: existingSubscription.tenantId },
        data: {
          isSuspended: false,
          suspendedReason: null,
        },
      });

      this.logger.log(`‚úÖ Odblokowano konto ${existingSubscription.tenantId} po udanej p≈Çatno≈õci`);

      // Wy≈õlij email o przywr√≥ceniu konta
      const nextBillingDate = new Date(stripeSubscription.current_period_end * 1000).toLocaleDateString('pl-PL');
      await this.emailService.sendAccountReactivatedEmail(tenant.email, {
        name: tenant.name,
        nextBillingDate,
      }).catch(err => {
        this.logger.error(`B≈ÇƒÖd wysy≈Çania emaila o przywr√≥ceniu konta:`, err);
      });
    }

    // Zapisz fakturƒô
    await this.prisma.invoices.create({
      data: {
        id: `inv_${Date.now()}`,
        tenantId: existingSubscription.tenantId,
        stripeInvoiceId: invoice.id,
        amount: invoice.amount_paid / 100,
        currency: invoice.currency.toUpperCase(),
        status: 'paid',
        invoiceUrl: invoice.hosted_invoice_url,
        invoicePdf: invoice.invoice_pdf,
        paidAt: new Date(invoice.status_transitions.paid_at! * 1000),
      },
    });

    this.logger.log(`‚úÖ Faktura op≈Çacona dla subskrypcji ${invoice.subscription}`);
  }

  private async handleInvoicePaymentFailed(invoice: Stripe.Invoice) {
    if (!invoice.subscription) {
      return;
    }

    const existingSubscription = await this.prisma.subscriptions.findFirst({
      where: { stripeSubscriptionId: invoice.subscription as string },
    });

    if (!existingSubscription) {
      return;
    }

    // Zapisz informacjƒô o nieudanej p≈Çatno≈õci
    await this.prisma.subscriptions.update({
      where: { id: existingSubscription.id },
      data: {
        status: 'PAST_DUE',
        lastPaymentStatus: 'failed',
        lastPaymentError: invoice.last_finalization_error?.message || 'P≈Çatno≈õƒá nieudana',
      },
    });

    const attemptCount = invoice.attempt_count || 1;
    
    this.logger.error(
      `‚ö†Ô∏è P≈Çatno≈õƒá nieudana dla ${existingSubscription.tenantId} - pr√≥ba ${attemptCount}`,
    );

    // Zablokuj konto TYLKO po 3 nieudanych pr√≥bach (oko≈Ço 3 dni)
    if (attemptCount >= 3) {
      await this.prisma.tenants.update({
        where: { id: existingSubscription.tenantId },
        data: {
          isSuspended: true,
          suspendedReason: 'P≈Çatno≈õƒá nieudana po 3 pr√≥bach - odn√≥w subskrypcjƒô',
        },
      });

      this.logger.error(
        `üö´ Zablokowano konto ${existingSubscription.tenantId} po 3 nieudanych pr√≥bach p≈Çatno≈õci`,
      );
    }

    // Wy≈õlij email z informacjƒÖ o nieudanej p≈Çatno≈õci
    const tenant = await this.prisma.tenants.findUnique({
      where: { id: existingSubscription.tenantId },
    });

    if (tenant) {
      // Utw√≥rz link do portalu klienta Stripe
      try {
        const portalSession = await this.stripe.billingPortal.sessions.create({
          customer: existingSubscription.stripeCustomerId,
          return_url: 'https://rezerwacja24.pl/dashboard/settings/subscription',
        });

        await this.emailService.sendPaymentFailedEmail(tenant.email, {
          name: tenant.name,
          attemptNumber: attemptCount,
          updatePaymentLink: portalSession.url,
        });

        this.logger.log(`üìß Wys≈Çano email o nieudanej p≈Çatno≈õci do ${tenant.email}`);
      } catch (emailError) {
        this.logger.error(`B≈ÇƒÖd wysy≈Çania emaila o nieudanej p≈Çatno≈õci:`, emailError);
      }
    }
  }

  private async handlePaymentMethodAttached(paymentMethod: Stripe.PaymentMethod) {
    if (!paymentMethod.customer) {
      return;
    }

    const existingSubscription = await this.prisma.subscriptions.findFirst({
      where: { stripeCustomerId: paymentMethod.customer as string },
    });

    if (!existingSubscription) {
      return;
    }

    await this.prisma.subscriptions.update({
      where: { id: existingSubscription.id },
      data: {
        stripePaymentMethodId: paymentMethod.id,
      },
    });

    this.logger.log(`Dodano metodƒô p≈Çatno≈õci dla klienta ${paymentMethod.customer}`);
  }

  /**
   * Synchronizuje subskrypcjƒô ze Stripe (rƒôcznie)
   */
  async syncSubscriptionFromStripe(tenantId: string) {
    try {
      this.logger.log(`üîÑ Synchronizacja subskrypcji dla tenant ${tenantId}`);

      // Pobierz tenant
      const tenant = await this.prisma.tenants.findUnique({
        where: { id: tenantId },
      });

      if (!tenant) {
        throw new BadRequestException('Firma nie istnieje');
      }

      // Znajd≈∫ klienta Stripe po email
      const customers = await this.stripe.customers.list({
        email: tenant.email,
        limit: 1,
      });

      if (customers.data.length === 0) {
        this.logger.warn(`Brak klienta Stripe dla tenant ${tenantId}`);
        return { synced: false, message: 'Brak klienta w Stripe' };
      }

      const customer = customers.data[0];

      // Pobierz subskrypcje klienta
      const subscriptions = await this.stripe.subscriptions.list({
        customer: customer.id,
        limit: 1,
        status: 'all',
      });

      if (subscriptions.data.length === 0) {
        this.logger.warn(`Brak subskrypcji Stripe dla tenant ${tenantId}`);
        return { synced: false, message: 'Brak subskrypcji w Stripe' };
      }

      const stripeSubscription = subscriptions.data[0];

      // Pobierz plan z metadata lub z price
      const planId = stripeSubscription.metadata?.planId;
      
      if (!planId) {
        this.logger.error('Brak planId w metadata subskrypcji');
        return { synced: false, message: 'Brak planId w subskrypcji' };
      }

      const trialEnd = stripeSubscription.trial_end
        ? new Date(stripeSubscription.trial_end * 1000)
        : null;

      const trialStart = stripeSubscription.trial_start
        ? new Date(stripeSubscription.trial_start * 1000)
        : null;

      // Utw√≥rz lub zaktualizuj subskrypcjƒô w bazie
      const subscription = await this.prisma.subscriptions.upsert({
        where: { tenantId },
        create: {
          id: `sub_${Date.now()}`,
          tenantId,
          planId,
          status: stripeSubscription.status === 'trialing' ? 'TRIALING' : 'ACTIVE',
          stripeCustomerId: customer.id,
          stripeSubscriptionId: stripeSubscription.id,
          stripePaymentMethodId: stripeSubscription.default_payment_method as string,
          currentPeriodStart: new Date(stripeSubscription.current_period_start * 1000),
          currentPeriodEnd: new Date(stripeSubscription.current_period_end * 1000),
          trialStart,
          trialEnd,
          createdAt: new Date(),
          updatedAt: new Date(),
        },
        update: {
          status: stripeSubscription.status === 'trialing' ? 'TRIALING' : 'ACTIVE',
          stripeCustomerId: customer.id,
          stripeSubscriptionId: stripeSubscription.id,
          stripePaymentMethodId: stripeSubscription.default_payment_method as string,
          currentPeriodStart: new Date(stripeSubscription.current_period_start * 1000),
          currentPeriodEnd: new Date(stripeSubscription.current_period_end * 1000),
          trialStart,
          trialEnd,
          updatedAt: new Date(),
        },
      });

      this.logger.log(`‚úÖ Zsynchronizowano subskrypcjƒô dla tenant ${tenantId}`);

      return { 
        synced: true, 
        subscription,
        message: 'Subskrypcja zsynchronizowana pomy≈õlnie' 
      };
    } catch (error) {
      this.logger.error('B≈ÇƒÖd podczas synchronizacji subskrypcji', error);
      throw error;
    }
  }

  /**
   * Zmienia plan subskrypcji (upgrade/downgrade)
   */
  async changePlan(tenantId: string, newPlanId: string) {
    try {
      this.logger.log(`Pr√≥ba zmiany planu dla tenant ${tenantId} na plan ${newPlanId}`);
      
      // Pobierz nowy plan
      const newPlan = await this.prisma.subscription_plans.findUnique({
        where: { id: newPlanId },
      });

      if (!newPlan || !newPlan.isActive) {
        throw new BadRequestException('Wybrany plan nie istnieje lub jest nieaktywny');
      }

      // Pobierz obecnƒÖ subskrypcjƒô
      const subscription = await this.prisma.subscriptions.findUnique({
        where: { tenantId },
        include: { subscription_plans: true },
      });

      if (!subscription) {
        throw new BadRequestException('Brak aktywnej subskrypcji');
      }

      // Sprawd≈∫ czy u≈ºytkownik pr√≥buje zmieniƒá na ten sam plan
      if (subscription.planId === newPlanId) {
        return {
          success: true,
          message: 'Posiadasz ju≈º wybrany plan',
          newPlan: newPlan.name,
        };
      }

      // Sprawd≈∫ czy u≈ºytkownik ma pod≈ÇƒÖczonƒÖ kartƒô
      if (!subscription.stripePaymentMethodId) {
        throw new BadRequestException('Aby zmieniƒá plan, najpierw dodaj kartƒô p≈ÇatniczƒÖ');
      }

      // Pobierz klienta Stripe
      const customer = await this.stripe.customers.retrieve(subscription.stripeCustomerId);
      if (!customer || customer.deleted) {
        throw new BadRequestException('B≈ÇƒÖd podczas weryfikacji danych p≈Çatno≈õci');
      }

      // Pobierz cenƒô z planu
      const priceId = newPlan.stripePriceId;
      if (!priceId) {
        throw new Error('Brak ceny dla wybranego planu');
      }

      // Znajd≈∫ subscription item ID
      const stripeSubscription = await this.stripe.subscriptions.retrieve(
        subscription.stripeSubscriptionId
      );
      
      if (!stripeSubscription.items.data || stripeSubscription.items.data.length === 0) {
        throw new Error('Nie znaleziono element√≥w subskrypcji w Stripe');
      }
      
      const subscriptionItemId = stripeSubscription.items.data[0].id;

      // Zaktualizuj subskrypcjƒô w Stripe
      const updatedSubscription = await this.stripe.subscriptions.update(
        subscription.stripeSubscriptionId,
        {
          items: [{
            id: subscriptionItemId,
            price: priceId,
          }],
          proration_behavior: 'create_prorations',
          metadata: {
            tenantId,
            planId: newPlanId,
          }
        }
      );

      // Zaktualizuj w bazie danych
      await this.prisma.subscriptions.update({
        where: { tenantId },
        data: {
          planId: newPlanId,
          updatedAt: new Date(),
        },
      });

      this.logger.log(`‚úÖ Zmieniono plan dla tenant ${tenantId} na ${newPlan.name}`);

      // Zaktualizuj limit SMS dla nowego planu
      const newFeatures = newPlan.features as any;
      const newSmsLimit = newFeatures.sms === -1 ? 999999 : newFeatures.sms;
      
      const tenant = await this.prisma.tenants.findUnique({
        where: { id: tenantId },
        select: { sms_usage: true },
      });
      
      const currentUsage = (tenant?.sms_usage as any) || { used: 0 };
      
      await this.prisma.tenants.update({
        where: { id: tenantId },
        data: {
          sms_usage: {
            used: currentUsage.used,
            limit: newSmsLimit,
            lastReset: currentUsage.lastReset || new Date().toISOString(),
          },
        },
      });

      return {
        success: true,
        newPlan: newPlan.name,
        message: `Plan zmieniony na ${newPlan.name}`,
      };
    } catch (error) {
      this.logger.error('B≈ÇƒÖd podczas zmiany planu', error);
      
      // Bardziej szczeg√≥≈Çowe komunikaty b≈Çƒôd√≥w
      if (error.code === 'resource_missing') {
        throw new BadRequestException('Nie znaleziono subskrypcji w systemie p≈Çatno≈õci');
      } else if (error.code === 'card_declined') {
        throw new BadRequestException('Karta zosta≈Ça odrzucona. Sprawd≈∫ dane karty lub skontaktuj siƒô z bankiem.');
      } else if (error.code === 'authentication_required') {
        throw new BadRequestException('Wymagane jest uwierzytelnienie p≈Çatno≈õci. Spr√≥buj ponownie.');
      } else if (error.type === 'StripeCardError') {
        // B≈ÇƒÖd karty
        throw new BadRequestException(`B≈ÇƒÖd karty: ${error.message}`);
      } else if (error.type === 'StripeInvalidRequestError') {
        // Nieprawid≈Çowe ≈ºƒÖdanie do Stripe
        this.logger.error(`B≈ÇƒÖd ≈ºƒÖdania do Stripe: ${error.message}`, error);
        throw new BadRequestException('WystƒÖpi≈Ç b≈ÇƒÖd podczas przetwarzania p≈Çatno≈õci. Prosimy spr√≥bowaƒá p√≥≈∫niej.');
      }
      
      throw error;
    }
  }
        data: {
          planId: newPlanId,
          updatedAt: new Date(),
        },
      });

      this.logger.log(`‚úÖ Zmieniono plan dla tenant ${tenantId} na ${newPlan.name}`);

      // Zaktualizuj limit SMS dla nowego planu
      const newFeatures = newPlan.features as any;
      const newSmsLimit = newFeatures.sms === -1 ? 999999 : newFeatures.sms;
      
      const tenant = await this.prisma.tenants.findUnique({
        where: { id: tenantId },
        select: { sms_usage: true },
      });
      
      const currentUsage = (tenant?.sms_usage as any) || { used: 0 };
      
      await this.prisma.tenants.update({
        where: { id: tenantId },
        data: {
          sms_usage: {
            used: currentUsage.used,
            limit: newSmsLimit,
            lastReset: currentUsage.lastReset || new Date().toISOString(),
          },
        },
      });

      return {
        success: true,
        newPlan: newPlan.name,
        message: `Plan zmieniony na ${newPlan.name}`,
      };
    } catch (error) {
      this.logger.error('B≈ÇƒÖd podczas zmiany planu', error);
      throw error;
    }
  }

  /**
   * Tworzy SetupIntent do bezpiecznego dodania karty
   */
  async createSetupIntent(tenantId: string) {
    try {
      // Pobierz tenant
      const tenant = await this.prisma.tenants.findUnique({
        where: { id: tenantId },
      });

      if (!tenant) {
        throw new BadRequestException('Firma nie istnieje');
      }

      // Pobierz w≈Ça≈õciciela tenanta przez tenant_users
      const tenantUserWithOwner = await this.prisma.tenant_users.findFirst({
        where: { tenantId, role: 'TENANT_OWNER' },
      });
      
      let ownerEmail: string | null = null;
      if (tenantUserWithOwner) {
        const ownerUser = await this.prisma.users.findUnique({
          where: { id: tenantUserWithOwner.userId },
        });
        ownerEmail = ownerUser?.email || null;
      }

      // Sprawd≈∫ czy jest subskrypcja z klientem Stripe
      const subscription = await this.prisma.subscriptions.findUnique({
        where: { tenantId },
      });

      let stripeCustomerId: string;

      if (subscription?.stripeCustomerId && !subscription.stripeCustomerId.startsWith('pending-')) {
        // U≈ºyj istniejƒÖcego klienta (ale nie pending)
        stripeCustomerId = subscription.stripeCustomerId;
      } else {
        // Utw√≥rz nowego klienta Stripe
        const email = ownerEmail || tenant.email || `${tenantId}@rezerwacja24.pl`;
        
        // Sprawd≈∫ czy klient ju≈º istnieje w Stripe
        const existingCustomers = await this.stripe.customers.list({
          email,
          limit: 1,
        });

        if (existingCustomers.data.length > 0) {
          stripeCustomerId = existingCustomers.data[0].id;
        } else {
          // Utw√≥rz nowego klienta
          const customer = await this.stripe.customers.create({
            email,
            name: tenant.name,
            metadata: {
              tenantId,
              tenantName: tenant.name,
            },
          });
          stripeCustomerId = customer.id;
        }

        // Zaktualizuj subskrypcjƒô je≈õli istnieje
        if (subscription) {
          await this.prisma.subscriptions.update({
            where: { tenantId },
            data: { stripeCustomerId },
          });
        }
      }

      const setupIntent = await this.stripe.setupIntents.create({
        customer: stripeCustomerId,
        payment_method_types: ['card'],
        metadata: {
          tenantId,
        },
      });

      this.logger.log(`Utworzono SetupIntent dla tenant ${tenantId}, customer ${stripeCustomerId}`);

      return {
        clientSecret: setupIntent.client_secret,
      };
    } catch (error) {
      this.logger.error('B≈ÇƒÖd podczas tworzenia SetupIntent', error);
      throw error;
    }
  }

  /**
   * Pobiera metodƒô p≈Çatno≈õci dla klienta
   */
  async getPaymentMethod(tenantId: string) {
    try {
      const subscription = await this.prisma.subscriptions.findUnique({
        where: { tenantId },
      });

      if (!subscription) {
        return { paymentMethod: null };
      }

      if (!subscription.stripePaymentMethodId) {
        // Spr√≥buj pobraƒá domy≈õlnƒÖ metodƒô p≈Çatno≈õci z Stripe
        const customer = await this.stripe.customers.retrieve(
          subscription.stripeCustomerId,
          { expand: ['invoice_settings.default_payment_method'] }
        ) as Stripe.Customer;

        const defaultPm = customer.invoice_settings?.default_payment_method as Stripe.PaymentMethod | null;
        
        if (defaultPm && defaultPm.card) {
          return {
            paymentMethod: {
              id: defaultPm.id,
              brand: defaultPm.card.brand,
              last4: defaultPm.card.last4,
              expMonth: defaultPm.card.exp_month,
              expYear: defaultPm.card.exp_year,
            },
          };
        }

        return { paymentMethod: null };
      }

      const paymentMethod = await this.stripe.paymentMethods.retrieve(
        subscription.stripePaymentMethodId
      );

      if (!paymentMethod.card) {
        return { paymentMethod: null };
      }

      return {
        paymentMethod: {
          id: paymentMethod.id,
          brand: paymentMethod.card.brand,
          last4: paymentMethod.card.last4,
          expMonth: paymentMethod.card.exp_month,
          expYear: paymentMethod.card.exp_year,
        },
      };
    } catch (error) {
      this.logger.error('B≈ÇƒÖd podczas pobierania metody p≈Çatno≈õci', error);
      return { paymentMethod: null };
    }
  }

  /**
   * Aktualizuje domy≈õlnƒÖ metodƒô p≈Çatno≈õci po SetupIntent
   */
  async updateDefaultPaymentMethod(tenantId: string, paymentMethodId: string) {
    try {
      const subscription = await this.prisma.subscriptions.findUnique({
        where: { tenantId },
      });

      if (!subscription) {
        throw new BadRequestException('Brak subskrypcji');
      }

      // Ustaw jako domy≈õlnƒÖ metodƒô p≈Çatno≈õci dla klienta
      await this.stripe.customers.update(subscription.stripeCustomerId, {
        invoice_settings: {
          default_payment_method: paymentMethodId,
        },
      });

      // Je≈õli jest aktywna subskrypcja, zaktualizuj te≈º jej metodƒô p≈Çatno≈õci
      if (subscription.stripeSubscriptionId) {
        await this.stripe.subscriptions.update(subscription.stripeSubscriptionId, {
          default_payment_method: paymentMethodId,
        });
      }

      // Zaktualizuj w bazie
      await this.prisma.subscriptions.update({
        where: { tenantId },
        data: {
          stripePaymentMethodId: paymentMethodId,
          updatedAt: new Date(),
        },
      });

      this.logger.log(`Zaktualizowano metodƒô p≈Çatno≈õci dla tenant ${tenantId}`);

      return { success: true };
    } catch (error) {
      this.logger.error('B≈ÇƒÖd podczas aktualizacji metody p≈Çatno≈õci', error);
      throw error;
    }
  }
}
